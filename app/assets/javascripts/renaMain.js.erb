var scene, camera, renderer, collidableMeshList, p1, p1pointer;
var Game = {

  initialize: function(){
    // SCENE
    scene = new THREE.Scene();
    // scene.add(new THREE.AxisHelper(100));
    // scene.add(new THREE.GridHelper(100,10));
    // CAMERA
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 4000 );
    camera.position.set(0,65,150);
    camera.lookAt(scene.position);
    // RENDERER
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    $("body").append( renderer.domElement );
    // STATS
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '2px';
    stats.domElement.style.left = '2px';
    stats.domElement.style.zIndex = 100;
    $("body").append( stats.domElement );
    // LIGHT
    var light = new THREE.PointLight(0xffffff);
    light.position.set(100,200,100);
    scene.add(light);
    // FLOOR
    var floorTexture = new THREE.ImageUtils.loadTexture( '<%= asset_path 'sand_texture1023.jpg' %>' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    // floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(250, 250, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -17;
    floor.rotation.x = Math.PI / 2;
    floor.rotation.z = Math.PI / 4;
    scene.add(floor);
    // SKYBOX
    var skyGeometry = new THREE.BoxGeometry( 1000, 1000, 1000 );
    var materialArray = [];
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-xpos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-xneg.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-ypos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-yneg.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-zpos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-zneg.png' %>' ),
      side: THREE.BackSide
    }));
    var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
    var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
    scene.add( skyBox );

    // CUSTOM
    // var geometry = new THREE.SphereGeometry( 15, 15, 8 );
    // var material = new THREE.MeshLambertMaterial( { color: 0x000088, transparent: true, opacity: 0.5 } );
    // mesh = new THREE.Mesh( geometry, material );
    // mesh.position.set(0,80,0);
    // scene.add(mesh);
    // SUPER SIMPLE GLOW EFFECT
    // use sprite because it appears the same from all angles
    // var spriteMaterial = new THREE.SpriteMaterial({
    //   map: new THREE.ImageUtils.loadTexture( '<%= asset_path 'glow.png' %>' ),
    //   useScreenCoordinates: false,
    //   color: 0x0000ff, transparent: false, blending: THREE.AdditiveBlending
    // });
    // var sprite = new THREE.Sprite( spriteMaterial );
    // sprite.scale.set(100, 100, 1.0);
    // mesh.add(sprite); // this centers the glow at the mesh

    // BOUNDARY WALLS
    var wireMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true } );
    var boundaryGem= new THREE.BoxGeometry( 250, 250, 20);
    boundary = new THREE.Mesh( boundaryGem, wireMaterial );
    boundary.rotation.y  = Math.PI / 4;
    boundary.position.y = 120;
    boundary.position.z = -90;
    boundary.position.x = -90;
    scene.add(boundary);

    boundary2 = boundary.clone();
    boundary2.position.z = +90;
    boundary2.position.x = +90;
    scene.add(boundary2);

    boundary3 = boundary.clone();
    boundary3.rotation.y = (Math.PI/4)*-1
    boundary3.position.z = -90;
    boundary3.position.x = 90;
    scene.add(boundary3);

    boundary4 = boundary.clone();
    boundary4.rotation.y = (Math.PI/4)*-1
    boundary4.position.z = 90;
    boundary4.position.x = -90;
    scene.add(boundary4);

    // Initialize collision array
    collidableMeshList = [];
    collidableMeshList.push(boundary);
    collidableMeshList.push(boundary2);
    collidableMeshList.push(boundary3);
    collidableMeshList.push(boundary4);

    // character
    p1 = new Character( { color: 0x00FF00, transparent: true, opacity: 0.5 } );
    p1.mesh.scale.set(0.25,0.25,0.25);
    p1.mesh.position.y = 15;
    p1.mesh.position.setZ(85);
    scene.add(p1.mesh);
    // TEST CUBE ROTATION POINTER
    p1pointer = new THREE.Mesh( new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial( { color: 0x00ff00, transparent: true, opacity: 0.5 } ) );
    p1pointer.position.set(p1.mesh.position.x , p1.mesh.position.y, p1.mesh.position.z );
    scene.add( p1pointer);

    // var loader = new THREE.JSONLoader();
    // loader.load('models/fleur.js', function(geometry2){
    //   mesh = new THREE.Mesh(geometry2);
    //   mesh.scale.set(1,1,1);
    //   mesh.position.y= 50;
    //   scene.add(mesh);
    // });

    animate();
  } // end init

} // end Game

function animate(){
  requestAnimationFrame( animate );
  renderer.render( scene, camera );
  update();
}

function update(){
  // camera, misc rotation update
  camera.lookAt( p1.mesh.position );
  p1.mesh.lookAt(p1pointer.position);
  // collision detection
  collisions();
  // controller updates
  controls();
  // fps update
  stats.update();
}

function collisions(){
  var originPoint = p1.mesh.position.clone();
  for (var vertexIndex = 0; vertexIndex < p1.head.geometry.vertices.length; vertexIndex++){
    var localVertex = p1.head.geometry.vertices[vertexIndex].clone();
    var globalVertex = localVertex.applyMatrix4( p1.mesh.matrix );
    var directionVector = globalVertex.sub( p1.mesh.position );
    var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
    var collisionResults = ray.intersectObjects( collidableMeshList );
    if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ){
      console.log("hit");
      p1.mesh.position.set(p1.mesh.position.x,p1.mesh.position.y, p1.mesh.position.z);
    }
  }
}