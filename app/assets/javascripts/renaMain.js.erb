var scene, camera, renderer, collidableMeshList, cube, p1pointer, p1vector;
var Game = {

  initialize: function(){
    // SCENE
    scene = new THREE.Scene();
    scene.add(new THREE.AxisHelper(100));
    scene.add(new THREE.GridHelper(100,10));
    // CAMERA
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 4000 );
    camera.position.set(0,65,150);
    camera.lookAt(scene.position);

    // RENDERER
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    $("body").append( renderer.domElement );

    // STATS
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '2px';
    stats.domElement.style.left = '2px';
    stats.domElement.style.zIndex = 100;
    $("body").append( stats.domElement );

    // TEST CUBE
    var geometry = new THREE.BoxGeometry(4,4,4);
    var material = new THREE.MeshBasicMaterial( { color: 0x00ff00, transparent: true, opacity: 0.5 } );
    cube = new THREE.Mesh( geometry, material );
    scene.add( cube );
    // pointer sphere for test cube
    p1pointer = new THREE.Mesh( new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial( { color: 0x00ff00, transparent: true, opacity: 0.5 } ) );
    p1pointer.position.set(cube.position.x , cube.position.y, cube.position.z );
    scene.add( p1pointer);
    // cube.add(p1pointer);
    // test vector for test cube
    p1vector = new THREE.Vector3( 0, 0, 0 );
    cube.add(p1vector);

    // LIGHT
    var light = new THREE.PointLight(0xffffff);
    light.position.set(100,250,100);
    scene.add(light);

    // FLOOR
    var floorTexture = new THREE.ImageUtils.loadTexture( '<%= asset_path 'sand_texture1023.jpg' %>' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    // floorTexture.repeat.set( 10, 10 );
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(250, 250, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -2;
    floor.rotation.x = Math.PI / 2;
    floor.rotation.z = Math.PI / 4;
    scene.add(floor);

    // SKYBOX
    var skyGeometry = new THREE.BoxGeometry( 1000, 1000, 1000 );
    var materialArray = [];
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-xpos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-xneg.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-ypos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-yneg.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-zpos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-zneg.png' %>' ),
      side: THREE.BackSide
    }));
    var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
    var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
    scene.add( skyBox );

    // CUSTOM
    var geometry = new THREE.SphereGeometry( 15, 15, 8 );
    var material = new THREE.MeshLambertMaterial( { color: 0x000088, transparent: true, opacity: 0.5 } );
    mesh = new THREE.Mesh( geometry, material );
    mesh.position.set(0,80,0);
    scene.add(mesh);

    // SUPER SIMPLE GLOW EFFECT
    // use sprite because it appears the same from all angles
    var spriteMaterial = new THREE.SpriteMaterial({
      map: new THREE.ImageUtils.loadTexture( '<%= asset_path 'glow.png' %>' ),
      useScreenCoordinates: false,
      color: 0x0000ff, transparent: false, blending: THREE.AdditiveBlending
    });
    var sprite = new THREE.Sprite( spriteMaterial );
    sprite.scale.set(100, 100, 1.0);
    mesh.add(sprite); // this centers the glow at the mesh

    // BOUNDARY
    var wireMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } );
    var boundaryGem= new THREE.BoxGeometry( 250, 250, 250, 8, 8, 8 );
    boundary = new THREE.Mesh( boundaryGem, wireMaterial );
    boundary.rotation.y  = Math.PI / 4;
    boundary.position.y = 120;
    scene.add(boundary);

    // Initialize collision array
    collidableMeshList = [];
    collidableMeshList.push(boundary);

    // var loader = new THREE.JSONLoader();
    // loader.load('models/fleur.js', function(geometry2){
    //   mesh = new THREE.Mesh(geometry2);
    //   mesh.scale.set(1,1,1);
    //   mesh.position.y= 50;
    //   scene.add(mesh);
    // });

    animate();
  } // end init

} // end Game

function animate(){
  requestAnimationFrame( animate );
  renderer.render( scene, camera );
  update();
}

function update(){
  // camera, misc rotation update
  camera.lookAt( cube.position );
  cube.lookAt(p1pointer.position);
  // controller updates
  controls();
  // collision detection
  // collisions();
  // fps update
  stats.update();
}

function collisions(){
  var originPoint = cube.position.clone();
  for (var vertexIndex = 0; vertexIndex < cube.geometry.vertices.length; vertexIndex++){
    var localVertex = cube.geometry.vertices[vertexIndex].clone();
    var globalVertex = localVertex.applyMatrix4( cube.matrix );
    var directionVector = globalVertex.sub( cube.position );
    var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
    var collisionResults = ray.intersectObjects( collidableMeshList );
    if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ){
      // console.log("hit");
      cube.position.set(cube.position.x,cube.position.y, cube.position.z);
    }
  }
}