// requestAnim shim layer by Paul Irish
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       ||
          window.webkitRequestAnimationFrame ||
          window.mozRequestAnimationFrame    ||
          window.oRequestAnimationFrame      ||
          window.msRequestAnimationFrame     ||
          function(/* function */ callback, /* DOMElement */ element){
            window.setTimeout(callback, 1000 / 60);
          };
})();
// GLOBAL VARIABLES
var scene, camera, renderer, collidableMeshList, p1, p2, bl;
var Game = {

  initialize: function(){
    // SCENE
    // scene = new THREE.Scene();
    scene = new Physijs.Scene();
    // scene.setGravity(new THREE.Vector3( 0, -5, 0 ));
    scene.addEventListener('update', function(){
      scene.simulate();
    });
    table_material = Physijs.createMaterial(
      new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( '<%= asset_path 'sand_texture1023.jpg' %>' ), ambient: 0xFFFFFF }),
      .9, // high friction
      .2 // low restitution
    );
    table_material.map.wrapS = table_material.map.wrapT = THREE.RepeatWrapping;
    // table_material.map.repeat.set( 5, 5 );
    table = new Physijs.BoxMesh(
      new THREE.BoxGeometry(250, 1, 250),
      table_material,
      0, // mass
      { restitution: .2, friction: .8 }
    );
    table.position.y = -17;
    table.rotation.y = Math.PI / 4;
    table.receiveShadow = true;
    scene.add( table );
    var friction = .8; // high friction
    var restitution = .3; // low restitution
    var material = Physijs.createMaterial(
        new THREE.MeshBasicMaterial({ color: 0x888888 }),
        friction,
        restitution
    );
    // Create a cube with friction of .8 and restitution of .3
    var mesh = new Physijs.BoxMesh(
        new THREE.BoxGeometry( 15, 15, 15 ),
        material
    );
    mesh.position.y = 50;
    mesh.position.x = 50;
    mesh.position.z = 50;
    scene.add(mesh);
    // scene.add(new THREE.AxisHelper(100));
    // scene.add(new THREE.GridHelper(100,10));
    // CAMERA
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 4000 );
    camera.position.set(0,65,150);
    camera.lookAt(scene.position);
    // RENDERER
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    $("body").append( renderer.domElement );
    // STATS
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '2px';
    stats.domElement.style.left = '2px';
    stats.domElement.style.zIndex = 100;
    $("body").append( stats.domElement );
    // LIGHT
    var light = new THREE.PointLight(0xffffff);
    light.position.set(100,200,100);
    scene.add(light);
    var l2 = new THREE.PointLight(0xffffff);
    l2.position.set(0,50,0);
    scene.add(l2);
    // FLOOR
    // var floorTexture = new THREE.ImageUtils.loadTexture( '<%= asset_path 'sand_texture1023.jpg' %>' );
    // floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    // floorTexture.repeat.set( 10, 10 );
    // var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    // var floorGeometry = new THREE.PlaneGeometry(250, 250, 10, 10);
    // var floor = new Physijs.PlaneMesh(floorGeometry, floorMaterial);
    // floor.position.y = -17;
    // floor.rotation.x = Math.PI / 2;
    // floor.rotation.z = Math.PI / 4;
    // scene.add(floor);
    // SKYBOX
    var skyGeometry = new THREE.BoxGeometry( 1000, 1000, 1000 );
    var materialArray = [];
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-xpos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-xneg.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-ypos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-yneg.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-zpos.png' %>' ),
      side: THREE.BackSide
    }));
    materialArray.push( new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture( '<%= asset_path 'dawnmountain-zneg.png' %>' ),
      side: THREE.BackSide
    }));
    var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
    var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
    scene.add( skyBox );

    // CUSTOM
    // var geometry = new THREE.SphereGeometry( 15, 15, 8 );
    // var material = new THREE.MeshLambertMaterial( { color: 0x000088, transparent: true, opacity: 0.5 } );
    // mesh = new THREE.Mesh( geometry, material );
    // mesh.position.set(0,80,0);
    // scene.add(mesh);
    // SUPER SIMPLE GLOW EFFECT
    // use sprite because it appears the same from all angles
    // var spriteMaterial = new THREE.SpriteMaterial({
    //   map: new THREE.ImageUtils.loadTexture( '<%= asset_path 'glow.png' %>' ),
    //   useScreenCoordinates: false,
    //   color: 0x0000ff, transparent: false, blending: THREE.AdditiveBlending
    // });
    // var sprite = new THREE.Sprite( spriteMaterial );
    // sprite.scale.set(100, 100, 1.0);
    // mesh.add(sprite); // this centers the glow at the mesh

    // BOUNDARY WALLS
    // var wireMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true } );
    // var boundaryGem= new THREE.BoxGeometry( 250, 250, 20);
    // boundary = new THREE.Mesh( boundaryGem, wireMaterial );
    // boundary.rotation.y  = Math.PI / 4;
    // boundary.position.y = 90;
    // boundary.position.z = -90;
    // boundary.position.x = -90;
    // scene.add(boundary);

    // boundary2 = boundary.clone();
    // boundary2.position.z = +90;
    // boundary2.position.x = +90;
    // scene.add(boundary2);

    // boundary3 = boundary.clone();
    // boundary3.rotation.y = (Math.PI/4)*-1
    // boundary3.position.z = -90;
    // boundary3.position.x = 90;
    // scene.add(boundary3);

    // boundary4 = boundary.clone();
    // boundary4.rotation.y = (Math.PI/4)*-1
    // boundary4.position.z = 90;
    // boundary4.position.x = -90;
    // scene.add(boundary4);

    // Initialize collision array
    // collidableMeshList = [];
    // collidableMeshList.push(boundary);
    // collidableMeshList.push(boundary2);
    // collidableMeshList.push(boundary3);
    // collidableMeshList.push(boundary4);

    // PLAYER 1
    p1 = new Character( { color: 0x00FF00, transparent: true, opacity: 0.5 } );
    p1.mesh.scale.set(0.25,0.25,0.25);
    p1.mesh.position.set(-60,15,50);
    scene.add(p1.mesh);
    p1.pointer.position.set(camera.position.x,camera.position.y,camera.position.z);
    $("<div>").attr('id','p1hp').text("Player 1").css({ position:'absolute', textAlign: 'center', height:'20px', bottom: '24px', backgroundColor: 'green'}).css('left',2).appendTo("body");

    // PLAYER 2
    p2 = new Character( { color: 0x0000FF, transparent: true, opacity: 0.5 } );
    p2.mesh.scale.set(0.25,0.25,0.25);
    p2.mesh.position.set(60,15,50);
    scene.add(p2.mesh);
    p2.pointer.position.set(camera.position.x,camera.position.y,camera.position.z);
    $("<div>").attr('id','p2hp').text("Player 2").css({ position:'absolute', textAlign: 'center', height:'20px', bottom: '2px', backgroundColor: 'blue'}).css('left',2).appendTo("body");

    bl = [];
    // setInterval( function(){
    //     scene.remove(bd);
    // }, 3000);

    // var loader = new THREE.JSONLoader();
    // loader.load('models/fleur.js', function(geometry2){
    //   mesh = new THREE.Mesh(geometry2);
    //   mesh.scale.set(1,1,1);
    //   mesh.position.y= 50;
    //   scene.add(mesh);
    // });

    animloop();
  } // end init

} // end Game

function animloop(){
  scene.simulate();
  requestAnimFrame(animloop);
  render();
};

function render(){
  renderer.render( scene, camera );
  update();
}

function update(){
  // camera, misc rotation update
  camera.lookAt( new THREE.Vector3((p1.mesh.position.x + p2.mesh.position.x)/2, (p1.mesh.position.y + p2.mesh.position.y)/2, (p1.mesh.position.z + p2.mesh.position.z)/2));
  var zoom = p1.mesh.position.distanceTo(p2.mesh.position)*0.5;
  if (zoom > 25 && zoom < 70){
    camera.fov = zoom;
  }
  camera.updateProjectionMatrix();
  p1.pointer.position.setY(p1.mesh.position.y);
  p1.mesh.lookAt(p1.pointer.position);
  p2.pointer.position.setY(p2.mesh.position.y);
  p2.mesh.lookAt(p2.pointer.position);
  // collision detection
  // collisions();
  p1.hitCollisions(p2);
  p2.hitCollisions(p1);
  // controller updates
  controls();
  p1.control();
  p2.control();
  // hp updates
  $("#p1hp").css('width', p1.hp );
  $("#p2hp").css('width', p2.hp );
  // remove bl
  if (bl.length > 10){
    scene.remove(bl.pop());
    scene.remove(bl.pop());
    scene.remove(bl.pop());
  }
  // fps update
  stats.update();
}

// function p1HitCollisions(){
//   var originPoint = p1.mesh.position.clone();
//   for (var vertexIndex = 0; vertexIndex < p1.head.geometry.vertices.length; vertexIndex++){
//     var localVertex = p1.head.geometry.vertices[vertexIndex].clone();
//     var globalVertex = localVertex.applyMatrix4( p1.mesh.matrix );
//     var directionVector = globalVertex.sub( p1.mesh.position );
//     var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
//     var collisionResults = ray.intersectObjects( p2.hitMeshes );
//     if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ){
//       p1.hit();
//     }
//   }
// }

// function p2HitCollisions(){
//   var originPoint = p2.mesh.position.clone();
//   for (var vertexIndex = 0; vertexIndex < p2.head.geometry.vertices.length; vertexIndex++){
//     var localVertex = p2.head.geometry.vertices[vertexIndex].clone();
//     var globalVertex = localVertex.applyMatrix4( p2.mesh.matrix );
//     var directionVector = globalVertex.sub( p2.mesh.position );
//     var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
//     var collisionResults = ray.intersectObjects( p1.hitMeshes );
//     if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ){
//       p2.hit();
//     }
//   }
// }

// function collisions(){
//   var originPoint = p1.mesh.position.clone();
//   for (var vertexIndex = 0; vertexIndex < p1.head.geometry.vertices.length; vertexIndex++){
//     var localVertex = p1.head.geometry.vertices[vertexIndex].clone();
//     var globalVertex = localVertex.applyMatrix4( p1.mesh.matrix );
//     var directionVector = globalVertex.sub( p1.mesh.position );
//     var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
//     var collisionResults = ray.intersectObjects( collidableMeshList );
//     if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ){
//       console.log("hit");
//       p1.hp -= 0.5;
//       p1.mesh.position.set(p1.mesh.position.x,p1.mesh.position.y, p1.mesh.position.z);
//     }
//   }
// }